<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Informatyka, Semestr I, Podstawy programowania komputerów</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<style>
body {background-color: #f6f6f6;}
blockquote {background-color: rgba(128,128,128,0.05);}
pre {background-color: rgba(128,128,128,0.05);}
</style>
</head>
<body><div class="container"><h1 id="szkielet-kodu-w-c">Szkielet kodu w C++</h1>

<pre class="prettyprint"><code class="language-C++ hljs vala"><span class="hljs-preprocessor">#include &lt;nazwa_biblioteki&gt;</span>

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])
{
    <span class="hljs-comment">//code goes here...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>Plik źródłowy w C++ <em>musi</em> zawierać jedynie definicję funkcji <code>main()</code>, choć może zawierać też dowolną ilość innych funkcji, dyrektyw preprocesora, oraz definicji zmiennych globalnych. <br>
Funkcja <code>main()</code> alternatywnie może mieć postać <code>int main() {...}</code>, parametry <code>argc</code> i <code>argv</code> służą do obsługi parametrów przekazanych przez system operacyjny z konsoli. <br>
Polecenie <code>return 0;</code> nie jest niezbędne (w C++, w C jest niezbędne) ale jest to wyjątek: <code>main()</code> to jedyna funkcja zwracająca <code>int</code>, w której nie musi wogóle pojawić się <code>return</code>, kompilator założy wtedy, że takie polecenie znajduje się po ostatniej linii kodu. <br>
Można po bloku <code>#include</code>, a przed definicją <code>main()</code>, wydać dyrektywę <code>using namespace std;</code>, co pozwala pomijać przedrostek <code>std::</code>. <br>
Dyrektywa <code>using namespace</code> informuje kompilator, że jeżeli natrafi na nieznany identyfikator, powinien próbować go znaleźć w przestrzeni nazw <code>std</code>. <br>
Analogicznie można dowolną inną przestrzeń nazw uczynić przeszukiwaną domyślnie.</p>

<h1 id="podstawowe-typy-danych">Podstawowe typy danych</h1>

<p>Deklaracja zmiennej: <br>
<code>&lt;typ&gt; &lt;identyfikator&gt;;</code> lub <code>&lt;typ&gt; &lt;identyfikator&gt;[&lt;rozmiar&gt;];</code> <br>
Definicja zmiennej; <br>
<code>&lt;typ&gt; &lt;identyfikator&gt; = &lt;wartość&gt;;</code> lub <code>&lt;typ&gt; &lt;identyfikator&gt;[&lt;rozmiar&gt;] = &lt;wartość&gt;;</code> <br>
<code>&lt;typ&gt;</code> może być nazwą klasy. <br>
Dany identyfikator nie może być zdefiniowany więcej niż raz in the same scope! (nie mam pomysłu jak przełożyć scope na polski)</p>

<p>Przykłady:</p>

<pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a; <span class="hljs-comment">// deklaracja zmiennej typu int o identyfikatorze a</span>
<span class="hljs-comment">//int a; // blad - ponowna deklaracja zmiennej a</span>
{
    <span class="hljs-keyword">int</span> a; <span class="hljs-comment">// dozwolone - different scope</span>
}
<span class="hljs-keyword">double</span> p; <span class="hljs-comment">// deklaracja zmiennej typu double o identyfikatorze p</span>
<span class="hljs-comment">//char a; // blad - zmienna o danej nazwie nie moze nagle zmienic typu</span>
<span class="hljs-keyword">double</span> x = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// definicja zmiennej x z przypisaniem wartosci 3.14</span>
<span class="hljs-comment">//double x = 1.2; // blad - ponowna definicja zmiennej x</span>
{
    <span class="hljs-keyword">double</span> x = <span class="hljs-number">1.2</span>; <span class="hljs-comment">// znow dozwolone</span>
    <span class="hljs-comment">//tutaj x ma wartosc 1.2</span>
}
<span class="hljs-comment">//tutaj x ma wartosc 3.14 bo inna zmienna x jest "in scope"</span>
<span class="hljs-keyword">float</span> arr[<span class="hljs-number">10</span>]; <span class="hljs-comment">// deklaracja tablicy 10 zmiennych typu float, indeksy od 0 do 9</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> word; <span class="hljs-comment">// deklaracja obiektu klasy std::string o identyfikatorze word</span></code></pre>

<h2 id="typy">Typy</h2>

<ul>
<li><code>int</code> - zmienna całkowitoliczbowa o zakresie wartości od -2147483648 do 2147483647</li>
<li><code>unsigned int</code> - zmienna całkowitoliczbowa o zakresie wartości od 0 do 4294967295</li>
<li><code>long long int</code> - zmienna całkowitoliczbowa o zakresie wartości od -9223372036854775808 do 9223372036854775807</li>
<li><code>float</code> - zmienna zmiennoprzecinkowa; obliczenia na zmiennych tego typu są niedokładne.</li>
<li><code>double</code> - zmienna zmiennoprzecinkowa o zakresie wartości od <script type="math/tex" id="MathJax-Element-461">1.7\cdot e^{-308}</script> do <script type="math/tex" id="MathJax-Element-462">1.7\cdot e^{308}</script>; bezpieczniej jest używać <code>double</code> zamiast <code>float</code> ze względu na większą (podwójną) precyzję obliczeń; zachować najwyższą ostrożność przy operacjach logicznych oraz przy używaniu jako warunków w instrukcjach sterujących, gdyż zmienne typu <code>float</code> i <code>double</code> mogą dawać niedokładne wyniki, np. <code>sqrt(4) == 2</code> może dać wynik <code>false</code>. <code>double</code> jest domyślnym typem zmiennoprzecinkowym w C++, więc wszystkie stałe dosłowne w kodzie będą własnie tego typu.</li>
<li><code>char</code> - zmienna znakowa; zawiera wartości z zakresu od -128 do 127; te wartości są zazwyczaj traktowane jako znaki w kodzie ASCII; zachować ostrożność przy porównywaniu/przypisywaniu!! wartość do takiej zmiennej przypisujemy w pojedynczych apostrofach <code>char znak = 'b';</code> lub jako liczbę <code>char znak = 36;</code> (znak $ ma kod 36), ale nie w cudzysłowach.</li>
<li><code>bool</code> - zmienna true/false; może zawierać tylko 0 lub 1; przy porównywaniu lub przypisaniu można użyć słów kluczowych <code>true</code> i <code>false</code></li>
<li>C-string - nie jest de facto typem, ale często jest tak traktowany. C-string jest tablicą <code>char</code>-ów zakończoną znakiem NULL (kod 0). <code>char znak = "b";</code> nie jest poprawne ponieważ <code>"b"</code> jest własnie C-stringiem - tablicą <strong>dwóch</strong> <code>char</code>-ów. W tej tablicy w komórce 0 jest znak ‘b’ a w komórce 1 znak NULL. Pochodzą z języka C i operować na nich można funkcjami z biblioteki <code>&lt;cstring&gt;</code>, ich użycie w C++ nie jest wskazane ze względu na istnienie klasy <code>std::string</code>.</li>
</ul>

<p>Każdy typ (ale nie klase) można poprzedzić słowem <code>unsigned</code> uzyskując zakres <code>0 do n</code> zamiast <code>-n/2 do n/2-1</code>. Przeciwne do niego jest słowo kluczowe <code>signed</code>. <br>
Podane tu rozmiary typów są przykładowe, niektóre kompilatory używają innej ilości pamięci dla tych typów.</p>

<h2 id="klasy">Klasy</h2>



<h3 id="łańcuch-znaków-stdstring">Łańcuch znaków - <code>std::string</code></h3>

<ul>
<li>wymaga dołączenia biblioteki <code>&lt;string&gt;</code></li>
<li>wartość do niej wpisujemy w cudzysłowiu <code>std::string slowo = "klucz";</code></li>
<li>pojedynczy znak można otrzymać na dwa sposoby: metodą <code>at()</code> - <code>std::cout &lt;&lt; slowo.at(2);</code> lub operatorem <code>[]</code> - <code>std::cout &lt;&lt; slowo[2];</code> tylko metoda <code>at()</code> sprawdza czy pożądany indeks faktycznie znajduje się w granicach stringu. jeżeli nie - rzuca wyjątek <code>std::out_of_range</code></li>
</ul>



<h3 id="kontener-o-stałym-rozmiarze-c11-stdarraytyp-rozmiar">Kontener o stałym rozmiarze (C++11) - <code>std::array&lt;typ, rozmiar&gt;</code></h3>

<ul>
<li>wymaga dołączenia biblioteki <code>&lt;array&gt;</code></li>
<li>przykładowa definicja <code>std::array&lt;int, 3&gt; tab = {1,2,3};</code></li>
<li>pojedynczy element można otrzymać na dwa sposoby: metodą <code>at()</code> - <code>std::cout &lt;&lt; tab.at(2);</code> lub operatorem <code>[]</code> - <code>std::cout &lt;&lt; tab[2];</code>, tylko metoda <code>at()</code> sprawdza czy pożądany indeks faktycznie znajduje się w granicach kontenera. jeżeli nie - rzuca wyjątek <code>std::out_of_range</code></li>
</ul>



<h3 id="kontener-o-zmiennym-rozmiarze-stdvectortyp">Kontener o zmiennym rozmiarze - <code>std::vector&lt;typ&gt;</code></h3>

<ul>
<li>wymaga dołączenia biblioteki <code>&lt;vector&gt;</code></li>
<li>przykładowa definicja <code>std::vector&lt;int&gt; vec = {1,2};</code></li>
<li>można dodawać do niego elementy metodą <code>push_back()</code> - <code>vec.push_back(3);</code></li>
<li>można usuwać z niego elementy metodą <code>pop_back()</code> - <code>vec.pop_back();</code></li>
<li>można sprawdzić jego rozmiar metodą <code>size()</code> - <code>std::cout &lt;&lt; vec.size();</code></li>
<li>pojedynczy element można otrzymać na dwa sposoby: metodą <code>at()</code> - <code>std::cout &lt;&lt; vec.at(2);</code> lub operatorem <code>[]</code> - <code>std::cout &lt;&lt; vec[2];</code>, tylko metoda <code>at()</code> sprawdza czy pożądany indeks faktycznie znajduje się w kontenerze. jeżeli nie - rzuca wyjątek <code>std::out_of_range</code></li>
</ul>



<h2 id="tablice">Tablice</h2>

<p>Tablice w C++ tworzymy dodając do nazwy zmiennej jej rozmiar w kwadratowych nawiasach.</p>



<pre class="prettyprint"><code class="language-C++ hljs cs"><span class="hljs-keyword">int</span> tab[<span class="hljs-number">10</span>];</code></pre>

<p>Nazwa tablicy to <em>wskaźnik</em> na jej pierwszy element.</p>



<h2 id="kody-ascii-skrót">Kody ASCII (skrót):</h2>

<ul>
<li>0 - NULL</li>
<li>1 do 31 - znaki specjalne(nowa linia, tabulator, powrót karetki…)</li>
<li>32 - spacja</li>
<li>33 do 47 - interpunkcja</li>
<li>48 do 57 - cyfry od 0 do 9</li>
<li>58 do 64 - więcej interpunkcji</li>
<li>65 do 90 - wielkie litery</li>
<li>91 do 96 - więcej więcej interpunkcji </li>
<li>97 do 122 - małe litery</li>
<li>123 do 126 - więcej więcej więcej interpunkcji</li>
<li>127 - znak(klawisz) delete</li>
</ul>

<h1 id="wskaźniki-i-dynamiczne-zarządzanie-pamięcią">Wskaźniki i dynamiczne zarządzanie pamięcią</h1>



<h2 id="wskaźniki">Wskaźniki</h2>

<p><em>Wskaźnik</em> to zmienna która zamiast wartości przechowuje adres w pamięci innej zmiennej.</p>

<p>Wskaźniki deklarujemy: <code>&lt;typ&gt; *&lt;identyfikator&gt;;</code> a definiujemy: <br>
<code>&lt;typ&gt; *&lt;identyfikator&gt;=&lt;adres&gt;;</code> gdzie <code>&lt;adres&gt;</code> może być: numerem komórki w pamięci, słowem kluczowym <code>nullptr</code>, identyfikatorem już istniejącego wskaźnika lub nazwą istniejącej zmiennej poprzedzoną znakiem <code>&amp;</code>.</p>

<p>Wskaźnika można też użyć do utworzenia nowej zmiennej słowem kluczowym <code>new</code>: <br>
<code>&lt;typ&gt; *&lt;identyfikator&gt;=new &lt;typ&gt;;</code>. <br>
Tworzenie tablicy w powyższy sposób: <br>
<code>&lt;typ&gt; *&lt;identyfikator&gt;=new &lt;typ&gt;[&lt;rozmiar&gt;];</code> <br>
Należy zawsze pamiętać o usunięciu takiej zmiennej, gdy nie jest dłużej potrzebna słowem kluczowym <code>delete</code>: <br>
<code>delete &lt;identyfkator&gt;;</code> <br>
<code>delete[] &lt;identyfikator&gt;;</code> <br>
Nie usunięcie zmiennej dynamicznej prowadzi do <em>wycieku pamięci</em>.</p>

<p>Przy korzystaniu ze wskaźników warto pamiętać o tym, że</p>



<pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>
<span class="hljs-keyword">int</span> *wsk = &amp;a;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; wsk;</code></pre>

<p>wypisze na ekran adres zmiennej <code>a</code> a nie jej zawartość, a</p>



<pre class="prettyprint"><code class="language-C++ hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>
<span class="hljs-keyword">int</span> <span class="hljs-variable">*wsk</span> = &amp;a;
std::cout &lt;&lt; <span class="hljs-variable">*wsk</span>;</code></pre>

<p>wypisze na ekran zawartość zmiennej <code>a</code>.</p>



<h2 id="struktury">Struktury</h2>

<p><em>Struktury</em> są to definiowane przez programistę obiekty używane do przechowywania danych.</p>

<p>Strukturę definiujemy w następujący sposób:</p>



<pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">struct</span> samochod
{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> marka;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> model;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> nr_rejestracyjny;
    <span class="hljs-keyword">int</span> waga;
    <span class="hljs-keyword">int</span> prędkosc;
};</code></pre>

<p>Po definicji struktury należy postawić <strong>średnik</strong>.</p>

<p>Korzystamy z takiej struktury w następujący sposób:</p>



<pre class="prettyprint"><code class="language-C++ hljs r">struct samochod{<span class="hljs-keyword">...</span>};
int main()
{
    samochod sam1;
    sam1.marka=<span class="hljs-string">"Skoda"</span>;
    sam1.waga=<span class="hljs-string">"1200"</span>;
    samochod sam2={<span class="hljs-string">"Fiat"</span>,<span class="hljs-string">"126p"</span>,<span class="hljs-string">"XYZ12AB"</span>,<span class="hljs-number">800</span>,<span class="hljs-number">90</span>};
    std::cout &lt;&lt; sam2.model;
}</code></pre>

<p>Jeżeli używamy wskaźnika na strukturę, operator kropki zastępujemy strzałką <code>-&gt;</code></p>

<h1 id="logika">Logika</h1>

<p>Praktycznie każde wyrażenie w C++ da się ocenić jako wyrażenie logiczne, co bywa mylące. Jest to spowodowane dwoma faktami: tym że każdy operator w C++ zwraca jakąś wartość, oraz tym że kompilator oceni każdą liczbę jako wyrażenie logiczne bez mrugnięcia okiem. Co za tym idzie:</p>

<pre class="prettyprint"><code class="language-C++ hljs cs"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) <span class="hljs-comment">//true jest jedoznaczne z 1 więc jest prawdziwe - petla nieskonczona</span>
    ;

<span class="hljs-keyword">while</span>(<span class="hljs-number">3.14</span>) <span class="hljs-comment">//3.14 nie jest zerem więc jest prawdziwe - pętla nieskończona</span>
    ;

<span class="hljs-keyword">int</span> t = <span class="hljs-number">10</span>;
<span class="hljs-keyword">while</span>(t--) <span class="hljs-comment">//petla wykona sie 10 razy...</span>
    ;</code></pre>

<p>Wybrane operatory: <br>
(operatory w C++ są tak naprawdę funkcjami i mają takie własnie nazwy)</p>

<ul>
<li><code>operator+</code> - dwuargumentowy, do pierwszego argumentu dodaje drugi i zwraca nową wartość pierwszego</li>
<li><code>operator-</code>, <code>operator-*</code> oraz <code>operator/</code>- dwuargumentowe, działają analogicznie jak <code>operator+</code> i zwracają nową wartość pierwszego argumentu</li>
<li><code>operator=</code> - dwuargumentowy, pierwszy musi być tzw. l-value czyli w jakiejś postaci miejscem w pamięci, np. nazwą zmiennej, drugi może być czymkolwiek. Przypisuje do podanej komórki pamięci wartość drugiego argumentu i zwraca tą właśnie wartość, więc <code>if(a = 5)</code> jest zawsze prawdziwe - to po prostu <code>if(5)</code></li>
<li><code>operator+=</code> - dwuargumentowy, podobny do <code>operator=</code> ale dodaje drugi argument do tego co juz jest w pierwszym. Zwraca nową wartość pierwszego.</li>
<li><code>operator-=</code> - dwuargumentowy, analogiczny do <code>operator+=</code> tylko odejmuje.</li>
<li><code>operator==</code> - dwuargumentowy, porównuje ze sobą oba argumenty i jeśli są równoważne zwraca <code>true</code> w przeciwnym razie <code>false</code>. Argumenty te nie zawsze są liczbami - mogą być jakimś wyrażeniem np. <code>if( (a = 5) == (a = 10) )</code> najpierw wykona te dwa przypisania by poznać ich wartość a dopiero potem porówna to co one zwrócą - czyli 5 z 10</li>
<li><code>operator&lt;=</code>, <code>operator&gt;=</code>, <code>operator&lt;</code> oraz <code>operator&gt;</code> - dwuargumentowe, wykonują arytmetyczne porównanie i zwracają wartość <code>true</code> lub <code>false</code></li>
<li><code>operator&amp;&amp;</code> oraz <code>operator||</code> - logiczne OR oraz AND, obowiązują te same zasady co dla <code>operator==</code>, zwracają wartość <code>true</code> lub <code>false</code></li>
<li><code>operator&amp;</code> oraz <code>operator|</code> - dwuargumentowe, bitowe OR oraz AND, zwracają wartość pierwszego argumentu po wykonaniu działania. Nie mylić z logicznym OR i AND! <code>if(2 &amp; 4)</code> jest fałszywe bo <code>2 &amp; 4</code> zwraca 0, a <code>2 &amp;&amp; 4</code> zwraca <code>true</code>. <code>if(2 | 4)</code> jest prawdziwe bo <code>2 | 4</code> zwraca 6, podczas <code>2 || 4</code> zwraca <code>true</code> (1).</li>
<li><code>operator^</code> - dwuargumentowy, bitowy XOR, nie ma odpowiednika logicznego. Zwraca liczbę.</li>
<li><code>operator&amp;&amp;</code></li>
</ul>

<h1 id="instrukcje-sterujące">Instrukcje sterujące</h1>



<h2 id="if">if</h2>

<p>Składnia: </p>



<pre class="prettyprint"><code class="language-C++ hljs ruby"><span class="hljs-keyword">if</span>(warunek_1)
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> wykonania jeżeli warunek <span class="hljs-number">1</span> jest prawdziwy
}
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(warunek_2)
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> wykonania jeżeli warunek <span class="hljs-number">2</span> jest prawdziwy
}
<span class="hljs-keyword">else</span>
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> wykonania jeżeli żaden z warunków nie jest prawdziwy
}</code></pre>

<p>Instrukcja sterująca <code>if()</code> może ale nie musi posiadać bloków <code>else if()</code> i <code>else</code>. BLoków <code>else if()</code> może być nieskończenie wiele, blok <code>else</code> może być tylko jeden.</p>

<p>Warunek może być:</p>

<ul>
<li>zmienną</li>
<li>wyrażeniem logicznym</li>
<li>funkcją(jeżeli funkcja ta zwraca wartość)</li>
<li>dowolną kombinacją powyższych</li>
</ul>

<p>Warunek jest fałszywy jeżeli wartość liczbowa wyrażenia to zero, a prawdziwy dla każdej innej wartości. Wyrażenie jest obliczane zawsze od lewej strony i tylko tak długo jak warunek nie jest fałszywy tzn. </p>



<pre class="prettyprint"><code class="language-C++ hljs r"><span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span> || i++ || j++ || k++)
{
    //<span class="hljs-keyword">...</span>
}</code></pre>

<p>nie spowoduje inkrementacji żadnej ze zmiennych jeżeli <code>a</code> nie jest równe zero.</p>



<h2 id="for">for</h2>

<p>Składnia: </p>



<pre class="prettyprint"><code class="language-C++ hljs ruby"><span class="hljs-keyword">for</span>(instrukcja_1;warunek;instrukcja_2)
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> powtórzenia
}</code></pre>

<p>Instrukcja 1 wykona się tylko raz; przed pętlą; nawet jeżeli warunek jest fałszywy; zazwyczaj definiuje się tu zmienną sterującą. <br>
Warunek jest sprawdzany przed każdym przebiegiem pętli według takich samych zasad jak <code>if()</code>. <br>
Instrukcja 2 wykona się po każdym przebiegu pętlil; zazwyczaj inkrementuje się tu zmienną sterującą.</p>



<h2 id="for-oparty-na-zbiorze-range-based-for-loop-c11">for oparty na zbiorze (range-based for loop) (C++11)</h2>

<p>Składnia:</p>



<pre class="prettyprint"><code class="language-C++ hljs ruby"><span class="hljs-keyword">for</span>(auto element <span class="hljs-symbol">:</span> zbiór)
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> powtórzenia
}</code></pre>

<p>Taką pętlę można stosować tylko na obiektach które są zbiorami, np. <code>std::vector</code>, <code>std::string</code>, <code>std::array</code> itd. Wykona się ona zawsze dokładnie tyle razy ile zbiór ma elementów, w każdym kolejnym przejściu <code>element</code> będzie innym elementem ze zbioru. Słowo kluczowe <code>auto</code> gwarantuje, że <code>element</code> będzie zmienną takiego typu, jakiego są elementy zbioru. </p>



<h2 id="while">while</h2>

<p>Składnia: </p>



<pre class="prettyprint"><code class="language-C++ hljs ruby"><span class="hljs-keyword">while</span>(warunek)
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> powtórzenia
}</code></pre>

<p>Warunek jest sprawdzany przed każdym przebiegiem pętli według takich samych zasad jak <code>if()</code>.</p>

<blockquote>
  <p>Warte zapamiętania:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cs">ifstream fin;
fin.open(<span class="hljs-string">"plik.txt"</span>);
<span class="hljs-keyword">int</span> a;
<span class="hljs-keyword">while</span>(fin &gt;&gt; a)
{
    <span class="hljs-comment">//instrukcje </span>
}</code></pre>
  
  <p>Będzie się wykonywać tak długo dopóki w pliku są liczby; jeżeli plik zawiera tylko liczby - do końca pliku.</p>
</blockquote>



<h2 id="dowhile">do{…}while</h2>

<p>Składnia: </p>



<pre class="prettyprint"><code class="language-C++ hljs ruby"><span class="hljs-keyword">do</span>
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> powtórzenia
}
<span class="hljs-keyword">while</span>(warunek);</code></pre>

<p>Warunek jest sprawdzany <strong>po</strong> każdym przebiegu pętli według takich samych zasad jak <code>if()</code>.</p>

<h1 id="funkcje">Funkcje</h1>

<blockquote>
  <p>sekcja w budowie</p>
</blockquote>

<hr>



<h1 id="wejściewyjście-konsoli-iostream">Wejście/wyjście konsoli - <code>&lt;iostream&gt;</code></h1>



<h2 id="strumień-wejściowy-stdcin">Strumień wejściowy - <code>std::cin</code></h2>

<blockquote>
  <p>Console INput <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a;
<span class="hljs-keyword">char</span> b;
<span class="hljs-keyword">float</span> c;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</code></pre>
  
  <p>wczytujemy ZE strumienia DO zmiennych więc <code>strumien &gt;&gt; zmienna</code> <br>
  Jeżeli w buforze nie znajduje się wystarczająco dużo znaków, program zaczeka na  podanie danych przez użytkownika.</p>
</blockquote>



<h2 id="strumień-wyjściowy-stdcout">Strumień wyjściowy - <code>std::cout</code></h2>

<blockquote>
  <p>Console OUTput <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;
<span class="hljs-keyword">char</span> b = <span class="hljs-string">'b'</span>;
<span class="hljs-keyword">float</span> c = <span class="hljs-number">3.14</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a= "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">",b= "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">",c= "</span> &lt;&lt; c; </code></pre>
  
  <p>wypisujemy ZE zmiennej DO strumienia więc <code>zmienna &lt;&lt; strumien</code></p>
</blockquote>



<h2 id="nowa-linia-stdendl">Nowa linia - <code>std::endl</code></h2>

<blockquote>
  <p>END Line <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl &lt;&lt; <span class="hljs-string">"world!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;</code></pre>
</blockquote>



<h2 id="ignorowanie-znaku-stdcinignore">Ignorowanie znaku - <code>std::cin.ignore()</code></h2>

<blockquote>
  <p>Pomija jeden znak znajdujący się w buforze. Przydatne jeżeli mamy tam niepotrzebny znak nowej linii po interakcji z użytkownikiem. <br>
  użycie: </p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> slowo;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; a;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>.ignore();
<span class="hljs-built_in">std</span>::getline(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>, slowo); <span class="hljs-comment">//wymaga biblioteki &lt;string&gt;</span></code></pre>
  
  <p>W tym przykładzie bez <code>std::cin.ignore()</code> funkcja <code>std::getline()</code> nie wczytała by nic poza znakiem nowej linii pozostawionym przez <code>std::cin</code>.</p>
</blockquote>



<h1 id="wejściewyjście-plikowe-fstream">Wejście/wyjście plikowe - <code>&lt;fstream&gt;</code></h1>



<h2 id="strumień-wewy-stdfstream">strumień we/wy - <code>std::fstream</code></h2>

<blockquote>
  <p>File STREAM <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs avrasm"><span class="hljs-label">std:</span>:fstream plik<span class="hljs-comment">;</span>
plik<span class="hljs-preprocessor">.open</span>(<span class="hljs-string">"plik.txt"</span>, <span class="hljs-keyword">std</span>::ios::<span class="hljs-keyword">in</span> | <span class="hljs-keyword">std</span>::ios::<span class="hljs-keyword">out</span>)<span class="hljs-comment">;</span>
plik &gt;&gt; a<span class="hljs-comment">;</span>
plik &lt;&lt; <span class="hljs-string">"hello world!"</span> &lt;&lt; <span class="hljs-keyword">std</span>::endl<span class="hljs-comment">;</span></code></pre>
  
  <p>przełączniki trybów:</p>
  
  <ul>
  <li>std::ios::in - INput - otwiera plik do odczytu</li>
  <li>std::ios::out - OUTput - otwiera plik do zapisu</li>
  <li>std::ios::binary - otwiera plik w trybie binarnym</li>
  <li>std::ios::ate - AT End - tylko w połączeniu z out; ustala pozycje zapisu na koniec pliku</li>
  <li>std::ios::app - APPend - tylko w połączeniu z out; zawartość strumienia wyjściowego zostanie dołączona do istniejącej zawartości</li>
  </ul>
  
  <p>Pliki zawsze należy zamykać metodą <code>close()</code></p>
  
  <pre class="prettyprint"><code class="language-C++ hljs perl">plik.<span class="hljs-keyword">close</span>();</code></pre>
</blockquote>



<h2 id="strumień-wejściowy-stdifstream">strumień wejściowy - <code>std::ifstream</code></h2>

<blockquote>
  <p>Input File STREAM <br>
  użycie: </p>
  
  <pre class="prettyprint"><code class="language-C++ hljs autohotkey"><span class="hljs-label">std::</span>ifstream plik<span class="hljs-comment">;</span>
plik.open(<span class="hljs-string">"plik.txt"</span>)<span class="hljs-comment">;</span>
plik &gt;&gt; <span class="hljs-literal">a</span><span class="hljs-comment">;</span></code></pre>
  
  <p>Pliki zawsze należy zamykać metodą <code>close()</code></p>
  
  <pre class="prettyprint"><code class="language-C++ hljs perl">plik.<span class="hljs-keyword">close</span>();</code></pre>
</blockquote>



<h2 id="strumień-wyjściowy-stdofstream">strumień wyjściowy - <code>std::ofstream</code></h2>

<blockquote>
  <p>Output File STREAM <br>
  użycie: </p>
  
  <pre class="prettyprint"><code class="language-C++ hljs avrasm"><span class="hljs-label">std:</span>:ofstream plik<span class="hljs-comment">;</span>
plik<span class="hljs-preprocessor">.open</span>(<span class="hljs-string">"plik.txt"</span>)<span class="hljs-comment">;</span>
plik &lt;&lt; <span class="hljs-string">"hello world!"</span> &lt;&lt; <span class="hljs-keyword">std</span>::endl<span class="hljs-comment">;</span></code></pre>
  
  <p>Pliki zawsze należy zamykać metodą <code>close()</code></p>
  
  <pre class="prettyprint"><code class="language-C++ hljs perl">plik.<span class="hljs-keyword">close</span>();</code></pre>
</blockquote>



<h2 id="sprawdzanie-otwarcia-pliku-stdfstreamisopen">sprawdzanie otwarcia pliku - <code>std::fstream::is_open</code></h2>

<blockquote>
  <p>metodę <code>is_open()</code> można wywołać na każdej klasie pochodnej od <code>fstream</code> - czyli <code>ifstream</code>, <code>ofstream</code> i <code>fstream</code>. <br>
  wartość zwracana jest typu <code>bool</code> - <code>true</code> jeśli plik istnieje i udało się go otworzyć, <code>false</code> w przeciwnym wypadku. <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-built_in">std</span>::fstream fileio(<span class="hljs-string">"file1.txt"</span>, <span class="hljs-built_in">std</span>::ios::in | <span class="hljs-built_in">std</span>::ios::out);
<span class="hljs-built_in">std</span>::ifstream fin(<span class="hljs-string">"file2.txt"</span>);
<span class="hljs-built_in">std</span>::ofstream fout(<span class="hljs-string">"file3.txt"</span>);
<span class="hljs-keyword">if</span>(fileio.is_open())
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"f1 success"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
<span class="hljs-keyword">if</span>(fin.is_open())
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"f2 success"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
<span class="hljs-keyword">if</span>(fin.is_open())
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"f3 success"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;</code></pre>
</blockquote>



<h1 id="funkcje-matematyczne-cmath">Funkcje matematyczne - <code>&lt;cmath&gt;</code></h1>



<h2 id="funkcje-trygonometryczne">Funkcje trygonometryczne:</h2>

<ul>
<li><code>sin()</code> - sinus</li>
<li><code>cos()</code> - cosinus</li>
<li><code>tan()</code> - tangens</li>
<li><code>asin()</code> - arcus sinus</li>
<li><code>acos()</code> - arcus cosinus</li>
<li><code>atan()</code> - arcus tangens</li>
<li><code>sinh()</code> - sinus hiperboliczny</li>
<li><code>cosh()</code> - cosinus hiperboliczny</li>
<li><code>tanh()</code> - tangens hiperboliczny</li>
</ul>

<p>Przyjmują jeden argument liczbowy, zwracają wartość tego samego typu.</p>



<h2 id="funkcje-logarytmiczne">Funkcje logarytmiczne:</h2>

<ul>
<li><code>log()</code> - logarytm naturalny</li>
<li><code>log10()</code> - logarytm przy podstawie 10</li>
</ul>

<p>Przyjmują jeden argument liczbowy, zwracają wartość tego samego typu.</p>



<h2 id="funkcje-potęg">Funkcje potęg:</h2>

<ul>
<li><code>T pow(T base, T exponent)</code> - Podnosi <code>base</code> do potęgi <code>exponent</code></li>
<li><code>T sqrt(T x)</code> - Pierwiastek z <code>x</code></li>
</ul>

<p>gdzie T to <code>double</code>, <code>float</code>, lub <code>long double</code></p>



<h1 id="manipulacja-wewy-iomanip">Manipulacja we/wy - <code>&lt;iomanip&gt;</code></h1>



<h2 id="podstawa-systemu-liczbowego-stdsetbase">Podstawa systemu liczbowego - <code>std::setbase</code></h2>

<blockquote>
  <p>użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">16</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setbase(<span class="hljs-number">16</span>) &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::endl;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setbase(<span class="hljs-number">10</span>) &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::endl;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setbase(<span class="hljs-number">8</span>) &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::endl;</code></pre>
  
  <p>efekt:</p>
  
  <pre class="prettyprint"><code class=" hljs ">10
16
20</code></pre>
  
  <p>Możliwe argumenty to 8, 10 i 16</p>
</blockquote>



<h2 id="znak-wiodący-stdsetfill">Znak wiodący - <code>std::setfill</code></h2>

<blockquote>
  <p>Ma zastosowanie tylko w połączeniu z <code>std::setw</code>. Ustawia znak wiodący, użyty jeżeli liczba ma mniej cyfr niż argument przekazany <code>std::setw</code>. <br>
  użycie: </p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">128</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setfill(<span class="hljs-string">'.'</span>) &lt;&lt; <span class="hljs-built_in">std</span>::setw(<span class="hljs-number">10</span>) &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::endl;</code></pre>
  
  <p>efekt:</p>
  
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-number">.128</span></code></pre>
</blockquote>



<h2 id="stała-szerokość-stdsetw">Stała szerokość - <code>std::setw</code></h2>

<blockquote>
  <p>Ustawia szerokość linii wypisanej na wyjście. Jeżeli wypisana liczba jest zbyt krótka przed nią pojawi się odpowiednia ilość spacji, lub znaku przekazanego <code>std::setfill</code> <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">128</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setfill(<span class="hljs-string">'.'</span>) &lt;&lt; <span class="hljs-built_in">std</span>::setw(<span class="hljs-number">10</span>) &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::endl;</code></pre>
  
  <p>efekt:</p>
  
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-number">.128</span></code></pre>
</blockquote>



<h2 id="miejsca-po-przecinku-stdsetprecision">Miejsca po przecinku - <code>std::setprecision</code></h2>

<blockquote>
  <p>Ustawia ilość miejsc po przecinku dla liczb zmiennoprzecinkowych. <br>
  użycie: </p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">double</span> f = <span class="hljs-number">3.14159</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">2</span>) &lt;&lt; f &lt;&lt; <span class="hljs-built_in">std</span>::endl;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">5</span>) &lt;&lt; f &lt;&lt; <span class="hljs-built_in">std</span>::endl;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">9</span>) &lt;&lt; f &lt;&lt; <span class="hljs-built_in">std</span>::endl;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::fixed;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">2</span>) &lt;&lt; f &lt;&lt; <span class="hljs-built_in">std</span>::endl;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">5</span>) &lt;&lt; f &lt;&lt; <span class="hljs-built_in">std</span>::endl;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">9</span>) &lt;&lt; f &lt;&lt; <span class="hljs-built_in">std</span>::endl;</code></pre>
  
  <p>efekt:</p>
  
  <pre class="prettyprint"><code class=" hljs ">3.1
3.1415
3.14159
3.14
3.14159
3.141590000</code></pre>
</blockquote>



<h1 id="funkcje-związane-z-czasem-ctime">Funkcje związane z czasem - <code>&lt;ctime&gt;</code></h1>



<h4 id="ctime-jest-biblioteką-języka-c-i-jej-użycie-z-powodów-których-nie-rozumiem-jest-obecnie-nie-wskazane-jako-zastępstwo-powinno-się-korzystać-z-opisanej-niżej-biblioteki-chrono"><strong><code>ctime</code> jest biblioteką języka C, i jej użycie z powodów których nie rozumiem, jest obecnie nie wskazane. Jako zastępstwo powinno się korzystać z opisanej niżej biblioteki <code>chrono</code>.</strong></h4>

<p><code>time(0)</code> - zwraca obecny czas jako liczbę sekund od 1 stycznia 1970, godziny 00:00; funkcja ta zwraca obiekt <code>time_t</code>, który <em>zazwyczaj</em> jest typem <code>int</code>.</p>



<h1 id="funkcje-związane-z-czasem-c11-chrono">Funkcje związane z czasem (C++11) - <code>&lt;chrono&gt;</code></h1>

<blockquote>
  <p>sekcja w budowie</p>
</blockquote>



<h2 id="punkt-w-czasie-stdchronotimepointzegar-zegarduration">Punkt w czasie - <code>std::chrono::time_point&lt;zegar, zegar::Duration&gt;</code></h2>

<blockquote>
  <p>Obiekt reprezentujący punkt w czasie, jako liczbę okresów od 1 stycznia 1970, godziny 00:00 <br>
  Długość jednego okresu jest zależna od parametru <code>zegar</code> szablonu. Nie zawsze jest to jedna sekunda.</p>
</blockquote>



<h2 id="systemowy-zegar-czasu-rzeczywistego-stdchronosystemclock">Systemowy zegar czasu rzeczywistego - <code>std::chrono::system_clock</code></h2>

<blockquote>
  <p>Zegar reprezentujący czas rzeczywisty, co za tym idzie można rzutować go na daty/godziny czytelne dla ludzi <br>
  Jego punktem odniesienia jest 1 stycznia 1970, godzina 00:00 <br>
  metody: <br>
  <code>std::chrono::system_clock::now()</code> - Zwraca obiekt klasy <code>std::chrono::time_point</code> reprezentujący obecny czas według systemowego zegara czasu rzeczywistego <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs ruby">auto current_time = <span class="hljs-symbol">std:</span><span class="hljs-symbol">:chrono</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:system_clock</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:now</span>();</code></pre>
</blockquote>



<h1 id="generowanie-liczb-pseudolosowych-c11-random">Generowanie liczb pseudolosowych (C++11) - <code>&lt;random&gt;</code></h1>

<blockquote>
  <p>sekcja w budowie</p>
</blockquote>

<hr>

<blockquote>
  <p>last update: 2018/12/11 - 00:16</p>
</blockquote></div></body>
</html>