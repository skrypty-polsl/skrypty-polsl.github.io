<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Informatyka, Semestr I, Podstawy programowania komputerów</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<style>
body {background-color: #f6f6f6;}
blockquote {background-color: rgba(128,128,128,0.05);}
pre {background-color: rgba(128,128,128,0.05);}
</style>
</head>
<body><div class="container"><h1 id="szkielet-programu-w-c">Szkielet programu w C++</h1>



<pre class="prettyprint"><code class="language-C++ hljs vala"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])
{
    <span class="hljs-comment">//code goes here...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>Funkcja main alternatywnie może mieć postać <code>int main() {...}</code>. <br>
Polecenie <code>return 0;</code> nie jest wymagane. <br>
Można po bloku <code>#include</code> wydać dyrektywę <code>using namespace std;</code>, co pozwala pomijać przedrostek <code>std::</code></p>



<h1 id="podstawowe-typy-danych">Podstawowe typy danych</h1>

<p>Deklaracja zmiennej: <br>
<code>&lt;typ&gt; &lt;identyfikator&gt;;</code> lub <code>&lt;typ&gt; &lt;identyfikator&gt;[&lt;rozmiar&gt;];</code> <br>
Definicja zmiennej; <br>
<code>&lt;typ&gt; &lt;identyfikator&gt; = &lt;wartość&gt;;</code> lub <code>&lt;typ&gt; &lt;identyfikator&gt;[&lt;rozmiar&gt;] = &lt;wartość&gt;;</code> <br>
Zmienna może mieć kilka deklaracji ale tylko jedną definicję!</p>



<h2 id="typy">Typy</h2>

<ul>
<li><code>int</code> - zmienna całkowitoliczbowa o zakresie wartości od -2147483648 do 2147483647</li>
<li><code>unsigned int</code> zmienna całkowitoliczbowa o zakresie wartości od 0 do 4294967295</li>
<li><code>double</code> - zmienna zmiennoprzecinkowa o zakresie wartości od <script type="math/tex" id="MathJax-Element-393">1,7\cdot e^{-308}</script> do <script type="math/tex" id="MathJax-Element-394">1,7\cdot e^{308}</script>; lepiej jest używać <code>double</code> zamiast <code>float</code> ze względu na większą precyzję obliczeń.</li>
<li><code>char</code> - zmienna znakowa; zawiera wartości z zakresu od -128 do 127; te wartości są zazwyczaj traktowane jako znaki w kodzie ASCII; zachować ostrożność przy porównywaniu/przypisywaniu!! wartość do takiej zmiennej wpisujemy w pojedynczych apostrofach <code>char znak = 'b';</code></li>
<li><code>bool</code> - zmienna true/false; może zawierać tylko 0 lub 1; przy porównywaniu lub przypisaniu można użyć słów kluczowych <code>true</code> i <code>false</code></li>
<li><code>std::string</code> - klasa służąca do przechowywania łańcuchów znaków; wymaga dołączenia biblioteki <code>&lt;string&gt;</code>; wartość do niej wpisujemy w cudzysłowiu <code>std::string slowo = "klucz";</code>; pojedynczy znak można otrzymać na dwa sposoby: metodą <code>at()</code> - <code>std::cout &lt;&lt; slowo.at(2);</code> lub operatorem <code>[]</code> - <code>std::cout &lt;&lt; slowo[2];</code></li>
</ul>

<h2 id="tablice">Tablice</h2>

<p>Tablice w C++ tworzymy dodając do nazwy zmiennej jej rozmiar w kwadratowych nawiasach.</p>

<pre class="prettyprint"><code class="language-C++ hljs cs"><span class="hljs-keyword">int</span> tab[<span class="hljs-number">10</span>];</code></pre>

<p>Nazwa tablicy to <em>wskaźnik</em> na jej pierwszy element.</p>

<h2 id="kody-ascii-skrót">Kody ASCII (skrót):</h2>

<ul>
<li>0 - NULL</li>
<li>1 do 31 - znaki specjalne(nowa linia, tabulator…)</li>
<li>32 - spacja</li>
<li>33 do 47 - interpunkcja</li>
<li>48 do 57 - cyfry od 0 do 9</li>
<li>58 do 64 - więcej interpunkcji</li>
<li>65 do 90 - wielkie litery</li>
<li>91 do 96 - więcej więcej interpunkcji </li>
<li>97 do 122 - małe litery</li>
<li>123 do 126 - więcej więcej więcej interpunkcji</li>
<li>127 - znak(klawisz) delete</li>
</ul>

<h1 id="instrukcje-sterujące">Instrukcje sterujące</h1>



<h2 id="if">if</h2>

<p>Składnia: </p>



<pre class="prettyprint"><code class="language-C++ hljs ruby"><span class="hljs-keyword">if</span>(warunek_1)
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> wykonania jeżeli warunek <span class="hljs-number">1</span> jest prawdziwy
}
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(warunek_2)
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> wykonania jeżeli warunek <span class="hljs-number">2</span> jest prawdziwy
}
<span class="hljs-keyword">else</span>
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> wykonania jeżeli żaden z warunków nie jest prawdziwy
}</code></pre>

<p>Instrukcja sterująca <code>if()</code> może ale nie musi posiadać bloków <code>else if()</code> i <code>else</code>. BLoków <code>else if()</code> może być nieskończenie wiele, blok <code>else</code> może być tylko jeden.</p>

<p>Warunek może być:</p>

<ul>
<li>zmienną</li>
<li>wyrażeniem logicznym</li>
<li>funkcją(jeżeli funkcja ta zwraca wartość)</li>
<li>dowolną kombinacją powyższych</li>
</ul>

<p>Warunek jest fałszywy jeżeli wartość liczbowa wyrażenia to zero, a prawdziwy dla każdej innej wartości. Wyrażenie jest obliczane zawsze od lewej strony i tylko tak długo jak warunek nie jest fałszywy tzn. </p>



<pre class="prettyprint"><code class="language-C++ hljs r"><span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span> || i++ || j++ || k++)
{
    //<span class="hljs-keyword">...</span>
}</code></pre>

<p>nie spowoduje inkrementacji żadnej ze zmiennych jeżeli <code>a</code> nie jest równe zero.</p>



<h2 id="for">for</h2>

<p>Składnia: </p>



<pre class="prettyprint"><code class="language-C++ hljs ruby"><span class="hljs-keyword">for</span>(instrukcja_1;warunek;instrukcja_2)
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> powtórzenia
}</code></pre>

<p>Instrukcja 1 wykona się tylko raz; przed pętlą; nawet jeżeli warunek jest fałszywy; zazwyczaj definiuje się tu zmienną sterującą. <br>
Warunek jest sprawdzany przed każdym przebiegiem pętli według takich samych zasad jak <code>if()</code>. <br>
Instrukcja 2 wykona się po każdym przebiegu pętlil; zazwyczaj inkrementuje się tu zmienną sterującą.</p>



<h2 id="while">while</h2>

<p>Składnia: </p>



<pre class="prettyprint"><code class="language-C++ hljs ruby"><span class="hljs-keyword">while</span>(warunek)
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> powtórzenia
}</code></pre>

<p>Warunek jest sprawdzany przed każdym przebiegiem pętli według takich samych zasad jak <code>if()</code>.</p>

<blockquote>
  <p>Warte zapamiętania:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cs">ifstream fin;
fin.open(<span class="hljs-string">"plik.txt"</span>);
<span class="hljs-keyword">int</span> a;
<span class="hljs-keyword">while</span>(fin &gt;&gt; a)
{
    <span class="hljs-comment">//instrukcje </span>
}</code></pre>
  
  <p>Będzie się wykonywać tak długo dopóki w pliku są liczby; jeżeli plik zawiera tylko liczby - do końca pliku.</p>
</blockquote>



<h2 id="dowhile">do{…}while</h2>

<p>Składnia: </p>



<pre class="prettyprint"><code class="language-C++ hljs ruby"><span class="hljs-keyword">do</span>
{
    <span class="hljs-regexp">//instrukcje</span> <span class="hljs-keyword">do</span> powtórzenia
}
<span class="hljs-keyword">while</span>(warunek);</code></pre>

<p>Warunek jest sprawdzany <strong>po</strong> każdym przebiegu pętli według takich samych zasad jak <code>if()</code>.</p>

<h1 id="wejściewyjście-konsoli-iostream">Wejście/wyjście konsoli - <code>&lt;iostream&gt;</code></h1>



<h2 id="strumień-wejściowy-stdcin">Strumień wejściowy - <code>std::cin</code></h2>

<blockquote>
  <p>Console INput <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a;
<span class="hljs-keyword">char</span> b;
<span class="hljs-keyword">float</span> c;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</code></pre>
  
  <p>wczytujemy ZE strumienia DO zmiennych więc <code>strumien &gt;&gt; zmienna</code> <br>
  Jeżeli w buforze nie znajduje się wystarczająco dużo znaków, program zaczeka na &gt; podanie danych przez użytkownika.</p>
</blockquote>



<h2 id="strumień-wyjściowy-stdcout">Strumień wyjściowy - <code>std::cout</code></h2>

<blockquote>
  <p>Console OUTput <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;
<span class="hljs-keyword">char</span> b = <span class="hljs-string">'b'</span>;
<span class="hljs-keyword">float</span> c = <span class="hljs-number">3.14</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a= "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">",b= "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">",c= "</span> &lt;&lt; c; </code></pre>
  
  <p>wypisujemy ZE zmiennej DO strumienia więc <code>zmienna &lt;&lt; strumien</code></p>
</blockquote>



<h2 id="nowa-linia-stdendl">Nowa linia - <code>std::endl</code></h2>

<blockquote>
  <p>END Line <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl &lt;&lt; <span class="hljs-string">"world!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;</code></pre>
</blockquote>



<h2 id="ignorowanie-znaku-stdcinignore">Ignorowanie znaku - <code>std::cin.ignore()</code></h2>

<blockquote>
  <p>Pomija jeden znak znajdujący się w buforze. Przydatne jeżeli mamy tam niepotrzebny znak nowej linii po interakcji z użytkownikiem. <br>
  użycie: </p>
  
  <pre class="prettyprint"><code class="language-C++ hljs cpp"><span class="hljs-keyword">int</span> a;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> slowo;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; a;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>.ignore();
<span class="hljs-built_in">std</span>::getline(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>, slowo); <span class="hljs-comment">//wymaga biblioteki &lt;string&gt;</span></code></pre>
  
  <p>W tym przykładzie bez <code>std::cin.ignore()</code> funkcja <code>std::getline()</code> nie wczytała by nic poza znakiem nowej linii pozostawionym przez <code>std::cin</code>.</p>
</blockquote>

<h1 id="wejściewyjście-plikowe-fstream">Wejście/wyjście plikowe - <code>&lt;fstream&gt;</code></h1>



<h2 id="strumień-wewy-stdfstream">strumień we/wy - <code>std::fstream</code></h2>

<blockquote>
  <p>File STREAM <br>
  użycie:</p>
  
  <pre class="prettyprint"><code class="language-C++ hljs avrasm"><span class="hljs-label">std:</span>:fstream plik<span class="hljs-comment">;</span>
plik<span class="hljs-preprocessor">.open</span>(<span class="hljs-string">"plik.txt"</span>, <span class="hljs-keyword">std</span>::ios::<span class="hljs-keyword">in</span> | <span class="hljs-keyword">std</span>::ios::<span class="hljs-keyword">out</span>)<span class="hljs-comment">;</span>
plik &gt;&gt; a<span class="hljs-comment">;</span>
plik &lt;&lt; <span class="hljs-string">"hello world!"</span> &lt;&lt; <span class="hljs-keyword">std</span>::endl<span class="hljs-comment">;</span></code></pre>
  
  <p>przełączniki trybów:</p>
  
  <ul>
  <li>std::ios::in - INput - otwiera plik do odczytu</li>
  <li>std::ios::out - OUTput - otwiera plik do zapisu</li>
  <li>std::ios::binary - otwiera plik w trybie binarnym</li>
  <li>std::ios::ate - AT End - tylko w połączeniu z out; ustala pozycje zapisu na koniec pliku</li>
  <li>std::ios::app - APPend - tylko w połączeniu z out; zawartość strumienia wyjściowego zostanie dołączona do istniejącej zawartości</li>
  </ul>
  
  <p>Pliki zawsze należy zamykać metodą <code>close()</code></p>
  
  <pre class="prettyprint"><code class="language-C++ hljs perl">plik.<span class="hljs-keyword">close</span>();</code></pre>
</blockquote>



<h2 id="strumień-wejściowy-stdifstream">strumień wejściowy - <code>std::ifstream</code></h2>

<blockquote>
  <p>Input File STREAM <br>
  użycie: </p>
  
  <pre class="prettyprint"><code class="language-C++ hljs autohotkey"><span class="hljs-label">std::</span>ifstream plik<span class="hljs-comment">;</span>
plik.open(<span class="hljs-string">"plik.txt"</span>)<span class="hljs-comment">;</span>
plik &gt;&gt; <span class="hljs-literal">a</span><span class="hljs-comment">;</span></code></pre>
  
  <p>Pliki zawsze należy zamykać metodą <code>close()</code></p>
  
  <pre class="prettyprint"><code class="language-C++ hljs perl">plik.<span class="hljs-keyword">close</span>();</code></pre>
</blockquote>



<h2 id="strumień-wyjściowy-stdofstream">strumień wyjściowy - <code>std::ofstream</code></h2>

<blockquote>
  <p>Output File STREAM <br>
  użycie: </p>
  
  <pre class="prettyprint"><code class="language-C++ hljs avrasm"><span class="hljs-label">std:</span>:ofstream plik<span class="hljs-comment">;</span>
plik<span class="hljs-preprocessor">.open</span>(<span class="hljs-string">"plik.txt"</span>)<span class="hljs-comment">;</span>
plik &lt;&lt; <span class="hljs-string">"hello world!"</span> &lt;&lt; <span class="hljs-keyword">std</span>::endl<span class="hljs-comment">;</span></code></pre>
  
  <p>Pliki zawsze należy zamykać metodą <code>close()</code></p>
  
  <pre class="prettyprint"><code class="language-C++ hljs perl">plik.<span class="hljs-keyword">close</span>();</code></pre>
</blockquote>

<hr>

<blockquote>
  <p>last update: 2017/1/29 - 14:37</p>
</blockquote></div></body>
</html>